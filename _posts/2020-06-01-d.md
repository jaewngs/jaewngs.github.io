---

title:  "Hierarchical Querry(계층적 질의) & PL/SQL 개념"

layout: post

---

# DAY 33


## [오늘 할 내용]
1. 함수와 프로시저를 구현 할 수 있다.
2. 쿼리를 사용하여 함수와 프로시저를 접목 할 수 있다.
3. JDBC를 사용하여 프로시저를 구현 할 수 있다.

***
**CMD에서 입력받는 키워드 : accept

~~~ sql
accept a -- a값을 받아 올 수 있게 커서 깜빡임

accept a prompt 'input a :'  -- 다음행 'input a :' 뜨고 값입력해서 a에 대입
~~~

#### ex) 사원의 이름을 입력받아 출력하는 구문을 만들어보자.
~~~ sql
SELECT ENAME, SAL
FROM EMP
WHERE ENAME = 'KING';
~~~

~~~ pl/sql
accept INPUT_NAME
SQL > KING -- KING이 INPUT_NAME 에 저장

DECLARE 
NAME EMP.ENAME%TYPE; 
SAL EMP.SAL%TYPE;

BEGIN 
SELECT ENAME, SAL INTO NAME, SAL_RES 
FROM EMP
WHERE ENAME = &INPUT_NAME;
DBMS_OUTPUT.PUT_LINE(NAME || '이 받는 월급 '|| SAL_RES);
END;
/

~~~


~~~ pl/sql
DECLARE
EMP_RES EMP % ROWTYPE;
BEGIN
SELECT ENAME, SAL INTO EMP_RES.ENAME, EMP_RES.SAL
FROM EMP
WHERE ENAME = &INPUT_NAME;
DBMS_OUTPUT.PUT_LINE(')
~~~

## 프로시져(PROCEDURE)

: 특정 작업을 수행 할 수 있고 이름이 있는 PL/SQL 블록으로서 매개 변수를 받을 수 있고 반복적으로 사용 할 수 있는 모듈

### [형식]
~~~ pl/sql
CREATE PROCEDURE -- 프로시져 이름
in argument -- (택1) in -- 실행 환경에서 program을 값을 전달
out argument -- (택1) out -- program에서 실행 환경을 값을 전달
in out argument -- (택1) in out -- 실행 환경에서 program으로 값을 전달하고 다시 프로그램에서 실행환경으로 변경된 값을 전달

is 
[변수의 선언]
begin
[PL/SQL Block] 
--SQL 문장, PL/SQL 제어 문장
[exception]   -- 선택
-- error가 발생 할 때 수행하는 문장
end 프로시져 이름;

~~~

**만들어진 stored procedure list 보기**
~~~ pl/sql
SELECT * FROM USER_PROCEDURES;
~~~

**프로시져의 내용까지 확인**
~~~ pl/sql
SELECT * FROM USER_SOURCE;
~~~

ex01) 부서 번호 20번인 사원의 사원번호, 이름, 봉급을 구하는 프로시져를 만들자.
~~~ sql
SELECT EMPNO, ENAME, SAL FROM EMP WHERE DEPTNO = 20;
~~~

~~~ pl/sql
SELECT EMPNO, ENAME, SAL INTO :a, :b, :c
FROM EMP
WHERE DEPTNO = 20;
~~~

~~~ pl/sql
CREATE OR REPLACE PROCEDURE EMP_EX01
IS
  V_EMPNO EMP.EMPNO%TYPE; -- 변수선언
  V_ENAME EMP.ENAME%TYPE;
  V_SAL NUMBER(7,2);

CURSOR EMP_CURSOR IS -- 1. 커서 선언 : 하나 이상의 row를 담을 객체
SELECT EMPNO,ENAME,SAL FROM EMP WHERE DEPTNO = 20;

BEGIN-- 실제 실행 코드
 OPEN EMP_CURSOR; -- 2. 커서 시작
    LOOP--한줄 이상 대입 변수 출력 , loop 구문 사용
      FETCH EMP_CURSOR INTO V_EMPNO,V_ENAME,V_SAL; -- 3. 변수를 대입

      EXIT WHEN EMP_CURSOR%ROWCOUNT > 5 OR EMP_CURSOR%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE(V_EMPNO||'  '||V_ENAME||'  '||V_SAL);
    END LOOP;
 CLOSE EMP_CURSOR;
END EMP_EX01;
/

EXEC EMP_EX01; --  실행하기
~~~
![image](https://user-images.githubusercontent.com/52989294/83380218-5c201c00-a418-11ea-959d-128614fdefd3.png)


Q1. 사원 테이블에서 사원의 이름과 봉급을 출력해보자.

~~~ pl/sql
CREATE OR REPLACE PROCEDURE EX_VIEW
IS
  R_NAME EMP.ENAME%TYPE; -- 변수선언
  R_SAL EMP.SAL%TYPE;

CURSOR RES IS -- 1. 커서 선언 : 하나 이상의 row를 담을 객체
SELECT ENAME,SAL FROM EMP;

BEGIN-- 실제 실행 코드
 OPEN RES; -- 2. 커서 시작
    LOOP--한줄 이상 대입 변수 출력 , loop 구문 사용
      FETCH RES INTO R_NAME,R_SAL; -- 3. 변수를 대입

      EXIT WHEN RES%ROWCOUNT > 3 OR RES%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE(R_ENAME || '  '||R_SAL||'  '||RES %ROWCOUNT);
    END LOOP;
 CLOSE RES;
END EX_VIEW;
/

EXEC EX_VIEW; --  실행하기
~~~

Q2. EX_VIEW01을 호출하게 되면 사원의 이름, 봉급, 커미션이 측정된 사원만 출력된다.
~~~ sql
SELECT ENAME, SAL, COMM 
FROM EMP 
WHERE COMM IS NOT NULL;
~~~

~~~ pl/sql
CREATE OR REPLACE PROCEDURE EX_VIEW01
IS
R_EMP EMP%ROWTYPE;
CURSOR RES IS
SELECT ENAME, SAL, COMM FROM EMP WHERE COMM IS NOT NULL;
BEGIN
OPEN RES;
LOOP
FETCH RES INTO R_EMP.ENAME, R_EMP.SAL, R_EMP.COMM;
EXIT WHEN RES%NOTFOUND;
DBMS_OUTPUT.PUT_LINE(R_EMP.ENAME||' '||R_EMP.SAL||' '||R_EMP.COMM);
END LOOP;
CLOSE RES;
END EX_VIEW01;
/

EXEC EX_VIEW01; -- 실행
~~~

![image](https://user-images.githubusercontent.com/52989294/83382132-642e8a80-a41d-11ea-9023-a6ce44237c48.png)