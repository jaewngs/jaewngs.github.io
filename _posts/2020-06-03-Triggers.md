---

title:  "PL/SQL Triggers & ORACLE PACKAGE & Error Handling(Exception)"

layout: post

---

# DAY 35

## [오늘 할 내용]
1. Triggers
2. ORACLE PACKAGE

***
<https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/triggers.htm#LNPLS99955>

### [9-1]
~~~ sql
CREATE OR REPLACE TRIGGER t
  BEFORE
    INSERT OR
    UPDATE OF SAL, DEPTNO OR
    DELETE
  ON RES_EMP
BEGIN
  CASE
    WHEN INSERTING THEN
      DBMS_OUTPUT.PUT_LINE('Inserting');
    WHEN UPDATING('SAL') THEN
      DBMS_OUTPUT.PUT_LINE('Updating salary');
    WHEN UPDATING('DEPTNO') THEN
      DBMS_OUTPUT.PUT_LINE('Updating department ID');
    WHEN DELETING THEN
      DBMS_OUTPUT.PUT_LINE('Deleting');
  END CASE;
END;
/
~~~
~~~ sql
INSERT INTO RES_EMP(EMPNO, ENAME) VALUES(1234, 'SSSS');
~~~
![image](https://user-images.githubusercontent.com/52989294/83583735-1b431700-a580-11ea-8a8d-f87e3df47937.png)

~~~ sql
UPDATE RES_EMP 
업데이트 SAL, DEPTNO
~~~

~~~ sql
DELETE 해보기
~~~


### [9-2]
~~~ sql
CREATE TABLE Emp_log (
  Emp_id     NUMBER,
  Log_date   DATE,
  New_salary NUMBER,
  Action     VARCHAR2(20));
~~~

~~~ sql
 CREATE OR REPLACE TRIGGER log_salary_increase
  2    AFTER UPDATE OF SAL ON RES_EMP
  3    FOR EACH ROW
  4  BEGIN
  5    INSERT INTO Emp_log (Emp_id, Log_date, New_salary, Action)
  6    VALUES (:NEW.EMPNO, SYSDATE, :NEW.SAL, 'New Salary');
  7  END;
  8  /

~~~

~~~ sql
UPDATE RES_EMP
  2  SET SAL = SAL + 1000
  3  WHERE DEPTNO = 20;
~~~

~~~ sql
SELECT * FROM Emp_log;
~~~


### [9-3] Conditional Trigger Prints Salary Change Information
~~~ sql




~~~

### [9-5] Trigger with REFERENCING Clause
~~~ sql
-- 테이블 이름이 NEW일 때 키워드NEW 와 겹치기 때문에 별칭 사용
~~~

***

<https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/triggers.htm#LNPLS752>

### [9-6] Trigger References OBJECT_VALUE Pseudocolumn
~~~ sql
-- 자주 사용하는 컬럼들 선언(AS OBJECT)해서 나만의 TYPE 만들기

~~~

***

<https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/triggers.htm#LNPLS20041>

### [9-7]

***

## ORACLE PACKAGE(패키지)
<https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/packages.htm#LNPLS009>

- 연관성 높은 함수나 PROCEDURE를 하나의 그룹으로 묶어서 관리하고 사용하는 것
- PACKAGE 는 PACKAGE 선언부(Spec)와 PACKAGE 몸체부(Body)로 구성
	- PACKAGE 선언부 : 해당 패키지에 사용될 함수나 프로시저, 변수 등에 대한 정의를 선언
	- PACKAGE 몸체부 : 선언부에 있는 정의된 식별에 실제 CODE로 구현되는 부분
	- 패키지 삭제
		- 패키지 선언부와 몸체부 모두 삭제 : DROP PACKAGE PACKAGE_NAME;
		- 패키지 몸체부만 삭제 : DROP PACKAGE BODY PACKAGE_NAME;

Q1. 사원 테이블에서 총 급여 합계와 평균 급여를 구하는 MY_PACKAGE를 만들어 실행하자.
~~~ sql
-- 1. 선언
CREATE OR REPLACE PACKAGE MY_PACKAGE
IS
PROCEDURE MY_SUM;
PROCEDURE MY_AVG;
END MY_PACKAGE;
/

-- 2. BODY 부분
CREATE OR REPLACE PACKAGE BODY MY_PACKAGE
IS

PROCEDURE MY_SUM
IS
CURSOR E_SUM 
IS 
SELECT SUM(NVL(SAL,0))
FROM EMP;
TOTAL_SUM NUMBER;

BEGIN
  OPEN E_SUM;
   FETCH E_SUM INTO TOTAL_SUM;
   DBMS_OUTPUT.PUT_LINE('봉급 합계 : ' || TOTAL_SUM);
  CLOSE E_SUM;
END MY_SUM;  -- 합계 구하는 PROCEDURE 끝

PROCEDURE MY_AVG -- 평균 구하는 PROCEDURE 시작
IS
CURSOR E_AVG IS 
SELECT AVG(NVL(SAL,0)) 
FROM EMP;

TOTAL_AVG NUMBER;
BEGIN
  OPEN E_AVG;
   FETCH E_AVG INTO TOTAL_AVG;
   DBMS_OUTPUT.PUT_LINE('봉급 평균 : ' || TOTAL_AVG);
  CLOSE E_AVG;
END MY_AVG; -- 평균 구하는 PROCEDURE 끝
END MY_PACKAGE;
/
~~~

~~~ sql
EXEC MY_PACKAGE.MY_SUM;

EXEC MY_PACKAGE.MY_AVG;
~~~

![image](https://user-images.githubusercontent.com/52989294/83587531-4a5e8600-a58a-11ea-80cd-57a710099e5e.png)


### [10-2]
~~~ sql

~~~

***

<https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/packages.htm#LNPLS00905>

### [10-3]
~~~ sql
-- 에러 잡고 정상 실행 시켜보자

~~~


## Error Handling(Exception)

### [11-6]
~~~ sql
DECLARE
  stock_price   NUMBER := 9.73;
  net_earnings  NUMBER := 0;
  pe_ratio      NUMBER;
BEGIN
  pe_ratio := stock_price / net_earnings;  -- raises ZERO_DIVIDE exception
  DBMS_OUTPUT.PUT_LINE('Price/earnings ratio = ' || pe_ratio);
END;
/
~~~
에러 발생
![image](https://user-images.githubusercontent.com/52989294/83589236-32890100-a58e-11ea-9f0a-21fcec52b382.png)

~~~ sql
-- EXCEPTION 처리하기
DECLARE
  stock_price   NUMBER := 9.73;
  net_earnings  NUMBER := 0;
  pe_ratio      NUMBER;
BEGIN
  pe_ratio := stock_price / net_earnings;  -- raises ZERO_DIVIDE exception
  DBMS_OUTPUT.PUT_LINE('Price/earnings ratio = ' || pe_ratio);
EXCEPTION
  WHEN ZERO_DIVIDE THEN
    DBMS_OUTPUT.PUT_LINE('Company had zero earnings.');
    pe_ratio := NULL;
END;
/
~~~

***

### Raising Exceptions Explicitly
- 객체가 소멸될 때 자동으로 호출되는 단어

<https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/errors.htm#LNPLS99869>

### [11-9]
~~~ sql
CREATE PROCEDURE account_status (
  due_date DATE,
  today    DATE
) AUTHID DEFINER
IS
  past_due  EXCEPTION;  -- declare exception
BEGIN
  IF due_date < today THEN
    RAISE past_due;  -- explicitly raise exception
  END IF;
EXCEPTION
  WHEN past_due THEN  -- handle exception
    DBMS_OUTPUT.PUT_LINE ('Account past due.');
END;
/
 
BEGIN
  account_status ('1-07-10', '9-07-10');
END;
/
~~~

### [11-11]
~~~ sql


~~~
![image](https://user-images.githubusercontent.com/52989294/83590185-21d98a80-a590-11ea-8882-f2889c33959a.png)

- 처음 초록 박스에서 EXCEPTION 발생 시 다음 초록 박스로 이동 
- 이동해서 EXCEPTION 발생 시 두번째 빨간 박스로 이동해서 처리

***

## SQL 구문을 이용해서 프로시져를 만들자.

~~~ sql
-- 1. String myemp_all = "SELECT * FROM My_Emp";
CREATE OR REPLACE PROCEDURE MYEMP_ALL(MYRES OUT SYS_REFCURSOR)
IS
BEGIN
  OPEN MYRES FOR SELECT * FROM My_Emp;
END;
/

-- 실행시켜보자.
VAR RES REFCURSOR;
EXEC MYEMP_ALL(:RES)

PRINT RES
~~~

***

~~~ sql
-- 2. ? 에 매개변수를 사용하겠다.
-- String myemp_vo = "SELECT * FROM MY_EMP WHERE ENAME = ?";
CREATE OR REPLACE PROCEDURE myemp_vo(MYNAME IN MY_EMP.ENAME%TYPE, MYRES OUT SYS_REFCURSOR)
IS
BEGIN
OPEN MYRES FOR
SELECT * FROM MY_EMP WHERE ENAME = MYNAME;
END;
/

-- 실행시켜보자.
VAR RES REFCURSOR;
EXEC myemp_vo('SMITH', :RES)

PRINT RES;
~~~

~~~ sql
-- 3. String myemp_vo2 = "SELECT * FROM MY_EMP WHERE ENAME = ? AND EMPNO = ?";
CREATE OR REPLACE PROCEDURE myemp_vo2(MYNAME IN MY_EMP.ENAME%TYPE, MYEMPNO IN MY_EMP.EMPNO%TYPE, MYRES OUT SYS_REFCURSOR)
IS
BEGIN
  OPEN MYRES FOR 
  SELECT * FROM MY_EMP WHERE ENAME = MYNAME AND EMPNO = MYEMPNO;
END;
/

-- 실행시켜보자.
VAR RES REFCURSOR;
EXEC myemp_vo2('KING', 7839, :RES)

PRINT RES;
~~~

~~~ sql
-- 4. INSERT
--	String myemp_insert = "INSERT INTO MY_EMP VALUES(?,?,?)";
CREATE OR REPLACE PROCEDURE myemp_insert(MYEMPNO IN MY_EMP.EMPNO%TYPE,MYNAME IN MY_EMP.ENAME%TYPE, MYDEPTNO IN MY_EMP.DEPTNO%TYPE)
IS
BEGIN
  INSERT INTO MY_EMP VALUES(MYEMPNO,MYNAME,MYDEPTNO);
END;
/

-- 실행시켜보자.
VAR RES REFCURSOR;
EXEC myemp_insert(4444,'ADSP',11)

SELECT * FROM MY_EMP;
~~~


~~~ sql
-- 5. DELETE(EMPNO를 받아 삭제하자.)
-- String myemp_delete = "DELETE FROM MY_EMP WHERE EMPNO = ?";
CREATE OR REPLACE PROCEDURE myemp_delete(MYEMPNO IN MY_EMP.EMPNO%TYPE)
IS
BEGIN
  DELETE FROM MY_EMP WHERE EMPNO = MYEMPNO;
END;
/

-- 실행시켜보자.
EXEC myemp_delete(4444)

SELECT * FROM MY_EMP;
~~~

~~~ sql
-- 6. UPDATE 사원번호를 찾아서 이름과 부서번호를 수정하자.
-- String myemp_update = "UPDATE MY_EMP SET ENAME = ?, DEPTNO = ? WHERE EMPNO = ?";
CREATE OR REPLACE PROCEDURE myemp_update(MYENAME IN MY_EMP.ENAME%TYPE,
MYDEPTNO IN MY_EMP.DEPTNO%TYPE, MYEMPNO IN MY_EMP.EMPNO%TYPE)
IS
BEGIN
  UPDATE MY_EMP SET ENAME = MYENAME, DEPTNO = MYDEPTNO WHERE EMPNO = MYEMPNO;
END;
/

-- 실행시켜보자.
EXEC myemp_update('JJJ', 10,222);

SELECT * FROM MY_EMP;
~~~


























































